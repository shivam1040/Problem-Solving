/*
Given weights and values of n items, we need to put these items in a knapsack of capacity w to get the maximum total value in the knapsack.
Note: Unlike 0/1 knapsack, you are allowed to break the item here. 

Example 1:

Input:
n = 3 
w = 50
value[] = {60,100,120}
weight[] = {10,20,30}
Output:
240.000000
Explanation:
Take the item with value 60 and weight 10, value 100 and weight 20 and split the third item with value 120 and weight 30, to fit it into weight 20. so it becomes (120/30)*20=80, so the total value becomes 60+100+80.0=240.0
Thus, total maximum value of item we can have is 240.00 from the given capacity of sack. 
Example 2:

Input:
n = 2
w = 50
value[] = {60,100}
weight[] = {10,20}
Output:
160.000000
Explanation:
Take both the items completely, without breaking.
Total maximum value of item we can have is 160.00 from the given capacity of sack.
Your Task :
Complete the function fractionalKnapsack() that receives maximum capacity w, an array of structure/class, and size n and returns a double value representing the maximum value in knapsack.
Note: The details of structure/class is defined in the comments above the given function.

Expected Time Complexity : O(NlogN)
Expected Auxilliary Space: O(1)

Constraints:
1 <= n <= 105
1 <= w <= 109
1 <= valuei, weighti <= 104
*/

/*
Intuition
The idea is to use greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we canâ€™t add the next item as a whole and at the end add the next item as much as we can.

Example:
Input: 
Items as (value, weight) pairs 
arr[] = {{100, 20}, {120, 30}, {60, 10}} 
Knapsack Capacity, W = 50

After sorting arr based on ratio, we will get:
arr[] = {{60, 10}, {100, 20}, {120, 30}} as their ratios are 6.0 >= 5.0 >= 4.0 respectively.
We can add item1 and item2 fully, getting finalValue as 160 and curWeight as 30.
At item3, we are left with remaining weight of 50 - 30 which is 20, so we can't add it fully as it is having weight 30.
              so we can simply add 20 by 30, which is 2/3 part of it, which will generate value 120*20/30 = 80.
              finalValue becomes ( 160 + 80 ) which is 240.
Return 240 as answer.
Implementation
Calculate the ratio(value/weight) for each item.
Sort all the items in decreasing order of the ratio.
Initialize curWeight(current weight we collected) and finalValue(it will be the final value generated with collected items) with 0.
Run a loop for i from 0 to N-1: 
           Do the following for every item "i" in the sorted order:
           case1) If the weight of the current item is less than or equal to the remaining capacity then 
                      add the value of that item into the finalValue.
                      add the weight of that item into the curWeight.
           case2) Else add the current item as much as we can and break out of the loop.
                      Value generated by it will be (total value of that item)*(remaining weight we can add) / (total weight of that item).
Return finalValue.
*/

//{ Driver Code Starts
import java.io.*;
import java.lang.*;
import java.util.*;

class Item {
    int value, weight;

    Item(int x, int y) {
        this.value = x;
        this.weight = y;
    }
}

class GfG {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            String inputLine[] = br.readLine().trim().split(" ");
            int n = Integer.parseInt(inputLine[0]);
            int w = Integer.parseInt(inputLine[1]);
            Item[] arr = new Item[n];
            inputLine = br.readLine().trim().split(" ");
            for (int i = 0, k = 0; i < n; i++) {
                arr[i] = new Item(Integer.parseInt(inputLine[k++]),
                                  Integer.parseInt(inputLine[k++]));
            }
            System.out.println(
                String.format("%.6f", new Solution().fractionalKnapsack(w, arr, n)));
        }
    }
}
// } Driver Code Ends


/*
class Item {
    int value, weight;
    Item(int x, int y){
        this.value = x;
        this.weight = y;
    }
}
*/

class Solution {
    // Function to get the maximum total value in the knapsack.
    double fractionalKnapsack(int w, Item arr[], int n) {
        // Your code here
        Arrays.sort(arr, new ItemComparator());
        double res=0;
        
        for(int i=0; i<n; i++){
            int x=Math.min(arr[i].weight, w);
            res+=x*1.0*arr[i].value/arr[i].weight;
            w-=x;
        }
        return res;
    }
}

class ItemComparator implements Comparator<Item> {
    // comparison function to sort items according to value/weight ratio.
    public int compare(Item a, Item b) {
        double r1 = (double)a.value / a.weight;
        double r2 = (double)b.value / b.weight;
        if (r1 > r2) {
            return -1;
        } else if (r1 < r2) {
            return 1;
        }
        return 0;
    }
}
